---
title: "W241 Final Project - Main Script"
author: "Fisher Kim, Kai Ying, Lucas Schroyer, Peter YH Kim"
date: '2022-04-03'
output:
  pdf_document: default
  word_document: default
---

## Introduction

This is the markdown script for a final project for the UC Berkeley School of Information - W241.


## Configurations and Load Packages
```{r global options, include = FALSE}
rm(list = ls())

setwd("/home/rstudio/w241_finalproject_KimSchroyerShiYing/notebooks")

knitr::opts_chunk$set(include = FALSE, message = FALSE, warning = FALSE )

knitr::knit_engines$set(problem_description = function(options) {
  code <- paste(options$code, collapse = "\n")
})

```

```{r load packages, message = FALSE}
if (!require("lmtest")) install.packages("lmtest")
if (!require("sandwich")) install.packages("sandwich")
if (!require("patchwork")) install.packages("patchwork")
if (!require("stargazer")) install.packages("stargazer")
if (!require("tidyverse")) install.packages("tidyverse")
if (!require("janitor")) install.packages("janitor")
if (!require("AER")) install.packages("AER")
if (!require("lubridate")) install.packages("lubridate")


library(data.table)
library(sandwich)
library(lmtest)

library(AER) 

library(ggplot2) 
library(patchwork)

library(tidyverse)
library(lubridate)
library(janitor)


```
## Theory and Background 


## Load and Clean Data


```{r load_data, echo=FALSE}
d <- fread('../src/data/W241 Survey StoryTelling Experiment_April 8, 2022_15.17.csv')

# Transform Column Names
d <- janitor::clean_names(d)

# Create Column Dictionary
d_dict <- d[1:1,]
d <- d[3:nrow(d),] #if exporting a csv from Qualtrics, use third row. Excel is 2

# Drop people that opted out before randomization
d <- d %>% filter(nda %like% "Yes")

# Get results from working directory
source("recode_referral_person.R")

# referral counts
d %>% count(referral_person) 

# Drop unnecessary columns
d <- d %>% 
  select(-ip_address, -progress, -recipient_first_name, -recipient_last_name, 
         -location_latitude, -location_longitude, -distribution_channel, -notice,
         -time_control_alien_click_count, -facts_aliens, -info_recycling, -facts_social) 
  
# Transform columns:
d <- d[, alien_treatment_bool := ifelse(alien_treatment == "", 0, 1)]
d <- d[, recyc_treatment_bool := ifelse(recycle_treatment == "", 0, 1)]
d <- d[, social_treatment_bool := ifelse(treatment_social == "", 0, 1)]

d <- d %>% rename(alien_quiz_for_1 = alien_quiz_q1, 
                  alien_quiz_for_2 = alien_quiz_q2,
                  alien_quiz_against_1 = alien_quiz_q4,
                  alien_quiz_against_2 = alien_quiz_q3,
                  recycle_quiz_for_1 = recycle_quiz_q2,
                  recycle_quiz_for_2 = recycle_quiz_q4,
                  recycle_quiz_against_1 = recycle_quiz_q1,
                  recycle_quiz_against_2 = recycle_quiz_q3,
                  social_quiz_for_1 = social_quiz_q1, 
                  social_quiz_for_2 = social_quiz_q2, 
                  social_quiz_against_1 = social_quiz_q3, 
                  social_quiz_against_2 = social_quiz_q4)
  


# Calculate what questions (for or against) each participant got right
quiz_results_raw <- d %>% select(contains("quiz")) 

quiz_answer_key_alien <- tibble(question = 
                            c("alien_quiz_for_1", "alien_quiz_for_2", 
                              "alien_quiz_against_1" ,"alien_quiz_against_2"), 
                          answer = 
                            c("10,000", "Only 19 out of the 144 reports",
                              "Project Aquatone", "National Geographic"))

quiz_answer_key_recycle <- tibble(question = 
                            c("recycle_quiz_for_1", "recycle_quiz_for_2", 
                              "recycle_quiz_against_1" ,"recycle_quiz_against_2"), 
                          answer = 
                            c("20 million cars off of U.S. roads and highways", 
                              "Recycling and composting, but not waste management",
                              "2-3","90%"))

quiz_answer_key_social <- tibble(question = 
                            c("social_quiz_for_1", "social_quiz_for_2", 
                              "social_quiz_against_1" ,"social_quiz_against_2"), 
                          answer = 
                            c("FamilyOK", 
                              "feel more connected to their friends",
                              "six", "Because of teensâ€™ impulsive natures"))

quiz_answer_key <- quiz_answer_key_alien %>% 
  bind_rows(quiz_answer_key_recycle) %>% 
  bind_rows(quiz_answer_key_social)


quiz_score <- function(col_name){

  question_answer <- quiz_answer_key %>% 
    filter(question == col_name) %>% 
    select(answer) %>% 
    as.character()
  
  col_correct <- as.integer(d[[col_name]] == question_answer)
  
  return(col_correct)
  }

d_graded <- quiz_results_raw %>% 
  names() %>% 
  map_dfc(quiz_score) 

names(d_graded) <- paste0(quiz_results_raw %>% 
  names(), "_correct")

d_graded_2 <- d %>% select(response_id) %>% bind_cols(d_graded)

d_graded_2 <- d_graded_2 %>% 
  mutate(alien_quiz_for_correct = (alien_quiz_for_1_correct + alien_quiz_for_2_correct)/2,
         recycle_quiz_for_correct = (recycle_quiz_for_1_correct + recycle_quiz_for_2_correct)/2,
         social_quiz_for_correct = (social_quiz_for_1_correct + social_quiz_for_2_correct)/2,
         alien_quiz_against_correct = (alien_quiz_against_1_correct + alien_quiz_against_2_correct)/2,
         recycle_quiz_against_correct = (recycle_quiz_against_1_correct + recycle_quiz_against_2_correct)/2,
         social_quiz_against_correct = (social_quiz_against_1_correct + social_quiz_against_2_correct)/2,
         quiz_for_correct = (alien_quiz_for_correct + recycle_quiz_for_correct + social_quiz_for_correct)/3,
         quiz_against_correct = (alien_quiz_against_correct + recycle_quiz_against_correct + social_quiz_against_correct)/3)

#Transpose so alien, recycle, and social media each have their own rows
d_2 <- d %>% 
  # select(alien_treatment_bool, recyc_treatment_bool, social_treatment_bool, sc1, sc2, sc3) %>%
  gather(key = "treatment_question", value = "treatment_bool", 
         alien_treatment_bool, recyc_treatment_bool, social_treatment_bool) %>% 
  mutate(sc1 = as.numeric(sc1),
         sc2 = as.numeric(sc2),
         sc3 = as.numeric(sc3)) %>% 
  mutate(sc1 = if_else(`treatment_question` == "alien_treatment_bool", `sc1`, 0),
         sc2 = if_else(`treatment_question` == "recyc_treatment_bool", `sc2`, 0),
         sc3 = if_else(`treatment_question` == "social_treatment_bool", `sc3`, 0),
         quiz_correct_num = sc1 + sc2 + sc3,
         quiz_perc_correct = as.double(quiz_correct_num)/4) %>% 
  left_join(d_graded_2, by = "response_id") %>% 
  arrange(response_id) %>% 
  mutate(alien_question = ifelse(treatment_question %like% 'alien', 1, 0),
         recycle_question = ifelse(treatment_question %like% 'recy', 1, 0),
         social_question = ifelse(treatment_question %like% 'social', 1, 0)) %>% 
  as.data.table()

# QC the transpose to make sure there is one question type per row
d_2 %>% 
  select(treatment_bool, alien_question, recycle_question, social_question,
         time_recycle_control_first_click, time_recycle_treat_first_click,
         time_control_alien_first_click, time_treat_alien_first_click,
         time_control_social_first_click, time_treat_social_first_click) %>% 
  mutate(qc_rec = ifelse(recycle_question == 1 & (
          (treatment_bool == 0 & time_recycle_control_first_click != "") |
          (treatment_bool == 1 & time_recycle_treat_first_click != "")), 1, 0),
         qc_alien = ifelse(alien_question == 1 & (
          (treatment_bool == 0 & time_control_alien_first_click != "") |
          (treatment_bool == 1 & time_treat_alien_first_click != "")), 1, 0),
         qc_soc = ifelse(social_question == 1 & (
           (treatment_bool == 0 & time_control_social_first_click != "") |
          (treatment_bool == 1 & time_treat_social_first_click != "")), 1, 0)
         ) %>% 
  filter(qc_rec == 0 & qc_alien == 0 & qc_soc == 0) %>% 
  glimpse()
# zero rows. successful transform as treat or control for each question.

# ### TODO  -  finish this ###
# # Remove text for non applicable rows (e.g. Alien info for recycling row)
# check_col <- function(col){
#   question_type <- ifelse(col %like% "alien", "alien",
#                           ifelse(col %like% "recy", "recy", 
#                                  ifelse(col %like% "social", "social", 
#                                         "none")))
#   return(question_type)
#   }
# 
# check_row <- function(row){
#   question_type <- ifelse(row %like% "alien", "alien",
#                           ifelse(row %like% "recy", "recy", 
#                                  ifelse(row %like% "social", "social", 
#                                         "none")))
#   return(question_type)
#   }
# 
# cross_check <- function(col, row){
#   row_question_type <- check_col(col)
#   col_question_type <- check_row(row)
#     
#   row_and_col_check <- ifelse(row_question_type == col_question_type, TRUE, FALSE)  
#   return(row_and_col_check)
#   }
# 
# d_2_cross_checked <- d_2 %>% 
#   mutate(time_recycle_control_first_click = ifelse(
#     cross_check(`time_recycle_control_first_click`, 
#                 `treatment_question`),
#     time_recycle_control_first_click,
#     ""))
# 
# # d_3 %>% count(treatment_question, time_recycle_control_first_click)
# d_2 %>% 
#   select(treatment_question, treatment_bool,time_recycle_control_first_click, time_recycle_treat_click_count) %>% 
#   filter(treatment_question %like% "recy") %>% 
#   mutate(qc = ifelse(treatment_bool == 0 & time_recycle_control_first_click != "", 1, 0)) %>% 
#   filter(qc > 0) %>% 
#   glimpse
# 
# d_2_cross_checked %>% 
#   select(treatment_question, time_recycle_control_first_click, time_recycle_treat_click_count) %>% 
#   filter(treatment_question %like% "recy") %>% 
#   glimpse

### End TODO section ###


d_3 <- d_2

# check the join 
d_3 %>% count(response_id, sc0, sc1, sc2, sc3) %>% glimpse() %>% filter(n>1)
d_3 %>% count(response_id, treatment_question, quiz_perc_correct)



# add a column indicating what type of question they got wrong (numerical vs topical)
d_4 <- d_3 %>% mutate(alien_quiz_numeric_1 = alien_quiz_for_1_correct,
         alien_quiz_numeric_2 = alien_quiz_for_2_correct,
         alien_quiz_category_1 = alien_quiz_against_1_correct, 
         alien_quiz_category_2 = alien_quiz_against_2_correct,
         recycle_quiz_numeric_1 = recycle_quiz_against_1_correct,
         recycle_quiz_numeric_2 = recycle_quiz_against_2_correct,
         recycle_quiz_category_1 = recycle_quiz_for_1_correct, 
         recycle_quiz_category_2 = recycle_quiz_for_2_correct,
         social_quiz_numeric_1 = social_quiz_against_1_correct,
         social_quiz_category_1 = social_quiz_for_1_correct,
         social_quiz_category_2 = social_quiz_for_2_correct, 
         social_quiz_category_3 = social_quiz_against_1_correct)

# add in a question_topic variable to join on later
d_4 <- d_4 %>% 
  mutate(question_topic = case_when(
           treatment_question %like% "alien" ~ "alien",
           treatment_question %like% "recyc" ~ "recycle",
           treatment_question %like% "social" ~ "social",
           TRUE ~ "other")
         ) 

d_final_pre_regressions <- d_4

```

# Quiz results by treatment group


```{r regression basic}

dat <- d_final_pre_regressions %>% 
  select(response_id, quiz_perc_correct, treatment_question, treatment_bool,
         alien_question, recycle_question, social_question, 
         question_topic) %>% 
  mutate(treatment_bool_factor = factor(treatment_bool)) %>% 
  unique() %>% 
  arrange(response_id)

# General Stats
dat %>% 
  group_by(treatment_bool) %>% 
  summarise(quiz_avg = mean(quiz_perc_correct),
            quiz_med = median(quiz_perc_correct))

# Stats by Question Type
dat %>% 
  group_by(treatment_bool, treatment_question) %>% 
  summarise(quiz_avg = mean(quiz_perc_correct),
            quiz_med = median(quiz_perc_correct))

ggplot(dat,
       aes(x=quiz_perc_correct,
           y = (..count..)/sum(..count..),
           fill=treatment_bool_factor)) + 
  geom_histogram(alpha=0.2, position="identity") + 
  scale_y_continuous(labels = scales::percent_format(accuracy = 1L)) +
  xlab("Percentage of Correct Answer on the Quiz") +
  ylab("Percentage of Responses")


ggplot(dat,
       aes(x=quiz_perc_correct,
           y = (..count..)/sum(..count..),
           fill=treatment_bool_factor)) + 
  geom_histogram(alpha=0.2, position="identity") +
  facet_wrap("question_topic") + 
  scale_y_continuous(labels = scales::percent_format(accuracy = 1L)) +
  xlab("Percentage of Correct Answer on the Quiz") +
  ylab("Percentage of Responses")



model_basic <- dat %>% 
  lm(quiz_perc_correct ~ treatment_bool, data = .)

summary(model_basic)


# See if there is a difference on the 'for' questions
model_for_basic <- d_3 %>% 
  select(response_id, quiz_for_correct, treatment_bool) %>% 
  unique() %>% 
  lm(quiz_for_correct ~ treatment_bool, data = .)

summary(model_for_basic)

# See if there is a difference on the 'against' questions
model_against_basic <- d_3 %>% 
  select(response_id, quiz_against_correct, treatment_bool) %>% 
  unique() %>% 
  lm(quiz_against_correct ~ treatment_bool, data = .)

summary(model_against_basic)


# Alien difference
model_basic_alien <- dat %>% 
  filter(alien_question == 1) %>% 
  lm(quiz_perc_correct ~ treatment_bool, data = .)

summary(model_basic_alien)

# Recycle difference
model_basic_recy <- dat %>% 
  filter(recycle_question == 1) %>% 
  lm(quiz_perc_correct ~ treatment_bool, data = .)

summary(model_basic_recy)

# Social Media difference
model_basic_social <- dat %>% 
  filter(social_question == 1) %>% 
  lm(quiz_perc_correct ~ treatment_bool, data = .)

summary(model_basic_social)

```

``` {r regression with covariates}


```


# Quiz results by question type


``` {r regression on numerical vs categorical question type}
# Data Transform
cat_questions <- c("alien_quiz_category_1", "alien_quiz_category_2",
         "recycle_quiz_category_1", "recycle_quiz_category_2",
         "social_quiz_category_1", "social_quiz_category_2", "social_quiz_category_3")

num_questions <- c("alien_quiz_numeric_1", "alien_quiz_numeric_2", 
         "recycle_quiz_numeric_1", "recycle_quiz_numeric_2",
         "social_quiz_numeric_1")


dat_cat_or_num <- d_final_pre_regressions %>% 
    select(response_id, question_topic,
         cat_questions,
         ) %>% 
    gather(key = "cat_or_num_question_topic", 
           value = "cat_or_num_question_correct", 
           cat_questions) %>% 
    unique() %>%
  bind_rows(
    d_final_pre_regressions %>% 
      select(response_id, question_topic,
             num_questions,
             ) %>% 
      gather(key = "cat_or_num_question_topic", 
             value = "cat_or_num_question_correct", 
             num_questions) %>% 
      unique()
    ) %>% 
  unique() %>% 
  mutate(cat_or_num_question_label = 
           ifelse(cat_or_num_question_topic %like% "numeric", 
                  "numeric", "category") ,
         cat_or_num_question_topic = case_when(
           cat_or_num_question_topic %like% "alien" ~ "alien",
           cat_or_num_question_topic %like% "recycle" ~ "recycle",
           cat_or_num_question_topic %like% "social" ~ "social",
           TRUE ~ "other")
         ) %>%
  filter(question_topic == cat_or_num_question_topic) %>% 
  select(-cat_or_num_question_topic) %>% 
  arrange(response_id)



# QC to make sure there are only 12 questions per topic
dat_cat_or_num %>% filter(response_id == "R_0JoNfdq3IWhf0LT") %>% glimpse()
stopifnot(nrow(dat_cat_or_num %>% count(response_id) %>% filter(n != 12)) == 0)
# each question has 12 responses

#QC no participants were dropped
stopifnot(length(unique(dat_cat_or_num$response_id)) == length(unique(d_final_pre_regressions$response_id)))
# None were dropped


# Part 1
# Check if the question type (Cat or Num) had an effect. Independent of treatment vs control
model_basic_cat_or_num <- dat_cat_or_num %>% 
  lm(cat_or_num_question_correct ~ cat_or_num_question_label, data = .)

summary(model_basic_cat_or_num)
# Yes, people did ~8% worse on average for numerical questions than for categorical questions

# Part 2
# Check if treatment or control had an effect on the number of correct by question type (Cat or Num)
dat_cat_or_num_2 <- d_final_pre_regressions %>% 
  select(response_id, question_topic, treatment_question, treatment_bool) %>% 
  unique() %>% 
  full_join(dat_cat_or_num, by = c("response_id","question_topic")
  )

# QC to make sure there are only 12 questions per topic
dat_cat_or_num_2 %>% filter(response_id == "R_0JoNfdq3IWhf0LT") %>% glimpse()
stopifnot(nrow(dat_cat_or_num_2 %>% count(response_id) %>% filter(n != 12)) == 0)
# each question has 12 responses

#QC no participants were dropped
stopifnot(length(unique(dat_cat_or_num_2$response_id)) == length(unique(d_final_pre_regressions$response_id)))
# None were dropped

model_basic_cat_or_num_with_treatment <- dat_cat_or_num_2 %>% 
  lm(cat_or_num_question_correct ~ treatment_bool + cat_or_num_question_label + treatment_bool*cat_or_num_question_label,
     data = .)

summary(model_basic_cat_or_num_with_treatment)
# It does not appear that the treatment impacted whether people did better or worse on the number vs categorical questions

```


# Opinion on the topic before and after treatment

```{r level of belief change}
# Must haves:
  # aliens_belief_change, social_belief_change, recycle_belief_change
  # social_belief, recycling_belief, alien_belief

# Optionals:
# alien_interest, recycling_interest, social_media_interest,
# alien_knowledgem, recycling_knowledge, social_media_knowledg

dat_change_in_belief <- d_final_pre_regressions %>% 
  select(response_id, question_topic, treatment_question, treatment_bool,
         aliens_belief_change, social_belief_change, recycle_belief_change,
          social_belief, recycling_belief, alien_belief)

source("recode_beliefs.R")
# returns "dat_change_in_belief_2" object


#TODO - think about any filters? e.g. do we want to filter out people who strongly believe in the topic as they can't really go up?
dat_change_in_belief_2 %>% filter(belief_answer_ohe_pre == 3) %>% count(belief_answer_ohe_post)
#   belief_answer_ohe_post  n
# 1                     -1  6
# 2                      0 40
# 3                      1 18
# there are lot's of instances where the narrative made them believe in a topic more strongly even when they answered 4


# Part 1
# Check if the treatment effect had an impact on if someone changes their opinion
model_basic_change_in_belief <- dat_change_in_belief_2 %>% 
  lm(belief_answer_ohe_post ~ treatment_bool, data = .)

summary(model_basic_change_in_belief)
# Yes, statistically significant results

# Part 2
# Check if the treatment effect had an impact on if someone changes their opinion based on prior belief
model_basic_change_in_belief_with_prior <- dat_change_in_belief_2 %>%
  # mutate(belief_answer_ohe_pre = belief_answer_ohe_pre %>% factor()) %>% 
  lm(belief_answer_ohe_post ~ treatment_bool + belief_answer_ohe_pre + 
       treatment_bool*belief_answer_ohe_pre, data = .)

summary(model_basic_change_in_belief_with_prior)
# No statistically significant results. not enough data?

# Part 3
# Check if the treatment effect had an impact on if someone changes their opinion based on prior belief conditional on the topic
model_basic_change_in_belief_with_prior_by_topic <- dat_change_in_belief_2 %>% 
  lm(belief_answer_ohe_post ~ treatment_bool + belief_answer_ohe_pre + question_topic +
       treatment_bool*belief_answer_ohe_pre + question_topic*belief_answer_ohe_pre + 
       treatment_bool*belief_answer_ohe_pre*question_topic, data = .)

summary(model_basic_change_in_belief_with_prior_by_topic)
# No statistically significant results

stargazer(model_basic_change_in_belief,
          model_basic_change_in_belief_with_prior, 
          model_basic_change_in_belief_with_prior_by_topic, 
          type = "text")
```
```{r time to complete the quiz}
# Must haves:
  # start_date, end_date, duration_in_seconds,
  # time_control_alien_page_submit, time_treat_alien_page_submit, alien_fact_time_page_submit,
  # time_recycle_treat_page_submit, time_recycle_control_page_submit, time_recy_info_page_submit,
  # time_treat_social_page_submit, time_control_social_page_submit, time_social_info_page_submit

# TODO - how do we determine the order in which they answered the questions?

dat_time_to_complete <- d_final_pre_regressions %>% 
  select(response_id, question_topic, treatment_question, treatment_bool,
          start_date, end_date, duration_in_seconds,
          time_control_alien_page_submit, time_treat_alien_page_submit, alien_fact_time_page_submit,
          time_recycle_treat_page_submit, time_recycle_control_page_submit, time_recy_info_page_submit,
          time_treat_social_page_submit, time_control_social_page_submit, time_social_info_page_submit
  )

source("recode_time_to_complete.R")
# returns "dat_time_to_complete_2" object


# Join with quiz data
dat_time_to_complete_with_quiz_scores  <- d_final_pre_regressions %>% 
  select(response_id, treatment_question,quiz_perc_correct, treatment_question, 
         treatment_question, treatment_bool,
         alien_question, recycle_question, social_question) %>% 
  mutate(treatment_bool_factor = factor(treatment_bool),
         question_topic = case_when(
          treatment_question %like% "alien" ~ "alien",
          treatment_question %like% "recyc" ~ "recycle",
          treatment_question %like% "social" ~ "social",
    TRUE ~ "other")) %>% 
  select(-treatment_question) %>% 
  unique() %>% 
  arrange(response_id) %>% 
  left_join(dat_time_to_complete_2, by = c("response_id", "question_topic", "treatment_bool"))

#TODO - QC join
stopifnot(d_final_pre_regressions %>% nrow() == dat_time_to_complete_with_quiz_scores %>% nrow())

# Plot the average time for each part
ggplot(dat_time_to_complete_2, 
       aes(x = time_question_page_submit,
           y = (..count..)/sum(..count..),
           color = factor(treatment_bool))) + 
  facet_wrap("question_topic") + 
  geom_histogram(bins = 60) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1L)) +
  xlab("Log Transform of Time to read narrative (sec)") + 
  ylab("Percentage of Responses") +
  scale_x_log10(breaks = scales::log_breaks()) 
  # scale_x_continuous() 


# Part 1 
# Check if time had an impact on quiz score by topic narrative page
model_basic_time_per_topic_narrative <- dat_time_to_complete_with_quiz_scores %>% 
  lm(quiz_perc_correct ~ quantile_rank_time_question_page_submit, data = .)


summary(model_basic_time_per_topic_narrative)

dat_time_to_complete_with_quiz_scores %>%
  ggplot(aes(x=quantile_rank_time_question_page_submit,y=quiz_perc_correct)) +
  geom_point(alpha=0.25) +
  geom_smooth(method = "lm", 
              mapping = aes(x=quantile_rank_time_question_page_submit,y=quiz_perc_correct)) 

# Yes, statistically significant results

# Part 2 - By topic fact page
model_basic_time_per_topic_facts <- dat_time_to_complete_with_quiz_scores %>%
  lm(quiz_perc_correct ~ quantile_rank_time_fact_page_submit, data = .)

summary(model_basic_time_per_topic_facts)

# Part 3 - By topic narrative and fact page
model_basic_time_per_topic <- dat_time_to_complete_with_quiz_scores %>%
  mutate(total_time = quantile_rank_time_question_page_submit + 
       quantile_rank_time_fact_page_submit) %>% 
  lm(quiz_perc_correct ~ total_time, data = .)
  # lm(quiz_perc_correct ~ quantile_rank_time_question_page_submit + 
  #      quantile_rank_time_fact_page_submit , data = .)

summary(model_basic_time_per_topic)


# Part 4  total time and treatment
model_basic_time_per_topic_with_treatment <- dat_time_to_complete_with_quiz_scores %>%
  mutate(total_time = quantile_rank_time_question_page_submit + 
       quantile_rank_time_fact_page_submit) %>% 
  lm(quiz_perc_correct ~ treatment_bool + total_time + treatment_bool*total_time,
     data = .)

summary(model_basic_time_per_topic_with_treatment)
# treatment was insignficant

```



